[input]
minimum_indexed_substring_length = 2
title_boost = "Ridiculous"
stemming = "English"

[[input.files]]
title = "@martinomburajr"
url = "/"
contents = "@martinomburajr\nHi my name is Martin Ombura Jr., a software engineer working mostly in Rust ðŸ¦€ and\nGo.\nI enjoy digging deep into the internals of how computers work and so most of\nmy posts will be look at the internals of most systems.\nTwitter: @martinomburajr\n"
filetype = "PlainText"
[[input.files]]
title = "Rust ðŸ¦€"
url = "/rust"
contents = "Rust Generics at An Assembly Level\nDate: April 25th, 2021\nRust like many programming languages today makes use of a programming construct\ncalled generics. Generics, more formally known as parametric polymorphism, is\ndefined as\na way to make a language more expressive, while still maintaining full static\ntype-safety.\nWhen making use of parametric polymorphism, a function or a data type can be\ndefined in an abstract way so as to be used freely across other types that\naccept the abstracted type. In Rust, generics allow a user to define a\n\"stand-in\" parameter to a set of\ntypes (functions, enums, structs, struct implementations)\nThe abstract nature of generics lends itself to confusion as one has to mix the\nnotion of an abstract type T with a concrete type such as a function, or\nstruct. This diverse dance between different abstractions can lead to increased cognitive\nload when trying to ascertain how a program might use the generic type.\nIn this article we explore the following:\nHow generic Rust code is compiled down to assembly code\nThe potential performance impact of generic code\nNote: This article is not an\nintroduction to generics\nUnderstanding Generic Abstraction\nOne guiding principle to remember about generics is that at a low level, a CPU can never execute\nsomething abstract (i.e something not clearly defined), and at some point, a\ngeneric definition must be converted into a concrete type ('clearly defined') so\nthat it can be executed.\nClearly defining a type is one of the many thing Rust does well by\nensuring strict enforcement of types at compile time. Meaning that at a certain\npoint, the Rust compiler will either convert the generic type into a concrete\none based on code you have supplied, or the compiler will ask you to be more specific.\nGenerics and Assembly\nIn the snippet above, we create a function non_generic_fn that takes in\nan argument b of type i64 and returns the same variable b as an i64.\nThis function acts as a simple \"pass-through\" function. We collect the result\nand store it in a variable _ans. We add the #[no_mangle] outer attribute to\nthe function to ensure our function names remain intact and are not modified or decorated by the\ncompiler. This is mostly for convenience when analyzing the resulting assembly.\nx86_64 Assembly: Regular Code\nThe snippet shown in CS1 isn't much but it will serve as a starting point as we investigate\nlater what happens when we introduce generics.\nLet's first generate the assembly.\n$cargo build;\n$objdump --x86-asm-syntax=att --demangle -d ../target/debug/ > ./src/non_generics.o\nIn CS5 below we have all the code in CS3 and CS4 without the annotations\nNow that we have an understanding of how Rust compiles to assembly, and how the\nassembly instructions are layed out for our simple non_generic_fn, let's take\na look at what happens when we compile a Rust generic function into assembly.\nx86_64 Assembly: Generic Code\nIn CS6 we have a generic function generic_fn that takes in a variable b of type T and returns an element of\ntype T.\nWe build the project then run\n$cargo build;\n$objdump --x86-asm-syntax=att --demangle -d ../target/debug/ > ./src/generics.o;\nAs we can see from the code snippet CS8, we have near identical assembly\noutput between the generic and non_generic outputs. There is virtually no\ndifference in number of instructions as well as allocations made by the CPU.\nConclusion\nGenerics are purely a programmer convenience tool that reduce repetition and can\ncommunicate the general characteristics of a Rust type. They have little to no\nimpact on performance as they contain no additional instructions when compiled\ndown to assembly and machine code.\nIn Rust they are an example of a zero-cost abstraction. We can thank the Rust compiler team for that!\nAdditional Resources\nx86_64 ABI (2018 Version) - https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-1.0.pdf\n"
filetype = "PlainText"
[output]
filename = "/Users/martinomburajr/dev/github.com/martinomburajr/blogg/public/index-en-US.st"
excerpts_per_result = 1
